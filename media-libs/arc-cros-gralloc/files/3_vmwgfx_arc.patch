diff --git a/vmwgfx.c b/vmwgfx.c
old mode 100644
new mode 100755
index 911cec8..c8fc6b9
--- a/vmwgfx.c
+++ b/vmwgfx.c
@@ -11,14 +11,13 @@
 #include <sys/mman.h>
 #include <vmwgfx_drm.h>
 #include <xf86drm.h>
-
 #include "drv_priv.h"
 #include "helpers.h"
 #include "util.h"
 #include "include/svga3d_types.h"
 
 static const uint32_t render_target_formats[] = { DRM_FORMAT_ARGB8888, 
-                          DRM_FORMAT_XRGB8888, DRM_FORMAT_XRGB1555, DRM_FORMAT_RGB565 };
+                          DRM_FORMAT_XRGB8888, DRM_FORMAT_XRGB1555, DRM_FORMAT_RGB565, DRM_FORMAT_ABGR8888 };
 
 static int vmwgfx_init(struct driver *drv)
 {
@@ -44,6 +43,8 @@ static const uint32_t drm_format_to_svga_format(uint32_t format)
         return SVGA3D_YUY2;
         case DRM_FORMAT_NV12:
         return SVGA3D_NV12;
+        case DRM_FORMAT_ABGR8888:
+        return SVGA3D_R8G8B8A8_UNORM;
         default:
         drv_log("UNKNOWN FORMAT %d\n", format);
         return 0;
@@ -55,7 +56,7 @@ static int vmwgfx_bo_create(struct bo *bo, uint32_t width, uint32_t height, uint
 {
     int ret;
     size_t plane;
-    uint32_t stride;
+    uint32_t stride, offset;
     uint32_t aligned_width, aligned_height;
     union drm_vmw_gb_surface_create_arg create_arg;
     struct drm_vmw_gb_surface_create_rep *rep = &create_arg.rep;
@@ -109,21 +110,67 @@ static int vmwgfx_bo_create(struct bo *bo, uint32_t width, uint32_t height, uint
     stride = drv_stride_from_format(format, width, 0);
     stride = ALIGN(stride, 64); 
     drv_bo_from_format(bo, stride, aligned_height, format);
-    for (plane = 0; plane < bo->num_planes; plane++) {
+    offset = 0;
+    for (plane = 0; plane < drv_num_planes_from_format(format); plane++) {
+        stride = drv_stride_from_format(format, width, plane);
+     //   drv_log("get hander:0x%x, plane:%zu\n", rep->handle, plane);  //fydeoslog
         bo->handles[plane].u32 = rep->handle;
+        bo->strides[plane] = stride;
+        bo->offsets[plane] = offset;
         bo->sizes[plane] = rep->backup_size;
+        offset += bo->sizes[plane];
     }
     return 0;
 }
 
+static void *vmwgfx_bo_map(struct bo *bo, struct vma *vma, size_t plane, uint32_t map_flags) {
+   union drm_vmw_gb_surface_reference_arg s_arg;
+   struct drm_vmw_surface_arg *req = &s_arg.req;
+   struct drm_vmw_gb_surface_ref_rep *rep = &s_arg.rep;
+   int ret;
+   void *addr;
+   req->sid = bo->handles[plane].u32;
+   req->handle_type = DRM_VMW_HANDLE_LEGACY;
+   ret = drmCommandWriteRead(bo->drv->fd, DRM_VMW_GB_SURFACE_REF,
+                 &s_arg, sizeof(s_arg));
+   if (ret) {
+     drv_log("Error get gb surface reference, ret:%d", ret);
+     return MAP_FAILED;
+   }
+   vma->length = rep->crep.backup_size;
+   bo->handles[plane].s32 = (int32_t) rep->crep.buffer_handle;
+   addr =  mmap(0, vma->length, drv_get_prot(map_flags), MAP_SHARED, bo->drv->fd,
+                rep->crep.buffer_map_handle);
+// drv_log("map offset:0x%llx, length:%zu, to addr:%p", rep->crep.buffer_map_handle, vma->length, addr);
+   return addr;
+}
+
+static int vmwgfx_bo_unmap(struct bo *bo, struct vma *vma){
+  struct drm_vmw_unref_dmabuf_arg arg;
+  int ret;
+  size_t plane;
+  uint32_t handle;
+  ret = munmap(vma->addr, vma->length);
+  for (plane = 0; plane < bo->num_planes; plane++) {
+    if (handle == (uint32_t) bo->handles[plane].s32)
+        continue;
+    else
+        handle = (uint32_t) bo->handles[plane].s32;
+    memset(&arg, 0, sizeof(arg));
+    arg.handle = handle;
+    drmCommandWrite(bo->drv->fd, DRM_VMW_UNREF_DMABUF, &arg, sizeof(arg));
+  }
+  return ret;
+}
+
 const struct backend backend_vmwgfx = {
     .name = "vmwgfx",
     .init = vmwgfx_init,
     .bo_create = vmwgfx_bo_create,
     .bo_import = drv_prime_bo_import,
     .bo_destroy = drv_dumb_bo_destroy,
-    .bo_map = drv_dumb_bo_map,
-    .bo_unmap = drv_bo_munmap,
+    .bo_map = vmwgfx_bo_map,
+    .bo_unmap = vmwgfx_bo_unmap,
 };
 
 #endif

diff --git a/drivers/gpu/drm/drm_connector.c b/drivers/gpu/drm/drm_connector.c
index 6011d76..9635bc1 100644
--- a/drivers/gpu/drm/drm_connector.c
+++ b/drivers/gpu/drm/drm_connector.c
@@ -254,8 +254,8 @@ int drm_connector_init(struct drm_device *dev,
 	config->num_connector++;
 	spin_unlock_irq(&config->connector_list_lock);
 
-	if (connector_type != DRM_MODE_CONNECTOR_VIRTUAL &&
-	    connector_type != DRM_MODE_CONNECTOR_WRITEBACK)
+	//if (connector_type != DRM_MODE_CONNECTOR_VIRTUAL &&
+	if (connector_type != DRM_MODE_CONNECTOR_WRITEBACK)
 		drm_object_attach_property(&connector->base,
 					      config->edid_property,
 					      0);
@@ -1537,7 +1537,7 @@ int drm_connector_update_edid_property(struct drm_connector *connector,
 	drm_object_property_set_value(&connector->base,
 				      dev->mode_config.non_desktop_property,
 				      connector->display_info.non_desktop);
-
+    //DRM_INFO("edid size:%ld", size);
 	ret = drm_property_replace_global_blob(dev,
 					       &connector->edid_blob_ptr,
 	                                       size,
diff --git a/drivers/gpu/drm/vmwgfx/device_include/svga3d_surfacedefs.h b/drivers/gpu/drm/vmwgfx/device_include/svga3d_surfacedefs.h
index f2bfd3d..9b4db82 100644
--- a/drivers/gpu/drm/vmwgfx/device_include/svga3d_surfacedefs.h
+++ b/drivers/gpu/drm/vmwgfx/device_include/svga3d_surfacedefs.h
@@ -1333,6 +1333,7 @@ svga3dsurface_is_gb_screen_target_format(SVGA3dSurfaceFormat format)
 		format == SVGA3D_R5G6B5   ||
 		format == SVGA3D_X1R5G5B5 ||
 		format == SVGA3D_A1R5G5B5 ||
+        format == SVGA3D_R8G8B8A8_UNORM ||
 		format == SVGA3D_P8);
 }
 
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_bo.c b/drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
index 2dda033..cf80752 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_bo.c
@@ -896,14 +896,14 @@ int vmw_user_bo_lookup(struct ttm_object_file *tfile,
 
 	base = ttm_base_object_lookup(tfile, handle);
 	if (unlikely(base == NULL)) {
-		DRM_ERROR("Invalid buffer object handle 0x%08lx.\n",
+		DRM_ERROR("Can't find buffer object handle 0x%08lx.\n",
 			  (unsigned long)handle);
 		return -ESRCH;
 	}
 
 	if (unlikely(ttm_base_object_type(base) != ttm_buffer_type)) {
 		ttm_base_object_unref(&base);
-		DRM_ERROR("Invalid buffer object handle 0x%08lx.\n",
+		DRM_ERROR("Invalid buffer object handle 0x%08lx.Invalid type\n",
 			  (unsigned long)handle);
 		return -EINVAL;
 	}
@@ -1121,3 +1121,4 @@ void vmw_bo_move_notify(struct ttm_buffer_object *bo,
 	if (mem->mem_type != VMW_PL_MOB && bo->mem.mem_type == VMW_PL_MOB)
 		vmw_resource_unbind_list(vbo);
 }
+
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c
index bb6dbbe..2355480 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c
@@ -521,7 +521,8 @@ static void vmw_get_initial_size(struct vmw_private *dev_priv)
 {
 	uint32_t width;
 	uint32_t height;
-
+    vmw_write(dev_priv, SVGA_REG_WIDTH, 1920);
+    vmw_write(dev_priv, SVGA_REG_HEIGHT, 1080);
 	width = vmw_read(dev_priv, SVGA_REG_WIDTH);
 	height = vmw_read(dev_priv, SVGA_REG_HEIGHT);
 
@@ -720,7 +721,9 @@ static int vmw_driver_load(struct drm_device *dev, unsigned long chipset)
 	dev_priv->vram_size = vmw_read(dev_priv, SVGA_REG_VRAM_SIZE);
 	dev_priv->mmio_size = vmw_read(dev_priv, SVGA_REG_MEM_SIZE);
 	dev_priv->fb_max_width = vmw_read(dev_priv, SVGA_REG_MAX_WIDTH);
+    DRM_INFO("SVGA max width:%d\n", dev_priv->fb_max_width);
 	dev_priv->fb_max_height = vmw_read(dev_priv, SVGA_REG_MAX_HEIGHT);
+    DRM_INFO("SVGA max height:%d\n", dev_priv->fb_max_height);
 
 	vmw_get_initial_size(dev_priv);
 
@@ -761,17 +764,21 @@ static int vmw_driver_load(struct drm_device *dev, unsigned long chipset)
 			vmw_read(dev_priv, SVGA_REG_MOB_MAX_SIZE);
 		dev_priv->stdu_max_width =
 			vmw_read(dev_priv, SVGA_REG_SCREENTARGET_MAX_WIDTH);
+        DRM_INFO("sdtu max width:%d\n", dev_priv->stdu_max_width);
 		dev_priv->stdu_max_height =
 			vmw_read(dev_priv, SVGA_REG_SCREENTARGET_MAX_HEIGHT);
+        DRM_INFO("sdtu max height:%d\n", dev_priv->stdu_max_height);
 
 		vmw_write(dev_priv, SVGA_REG_DEV_CAP,
 			  SVGA3D_DEVCAP_MAX_TEXTURE_WIDTH);
 		dev_priv->texture_max_width = vmw_read(dev_priv,
 						       SVGA_REG_DEV_CAP);
+        DRM_INFO("texture max width:%d\n", dev_priv->texture_max_width);
 		vmw_write(dev_priv, SVGA_REG_DEV_CAP,
 			  SVGA3D_DEVCAP_MAX_TEXTURE_HEIGHT);
 		dev_priv->texture_max_height = vmw_read(dev_priv,
 							SVGA_REG_DEV_CAP);
+        DRM_INFO("texture max height:%d\n", dev_priv->texture_max_height);
 	} else {
 		dev_priv->texture_max_width = 8192;
 		dev_priv->texture_max_height = 8192;
@@ -1160,7 +1167,6 @@ static long vmw_generic_ioctl(struct file *filp, unsigned int cmd,
 	/*
 	 * Do extra checking on driver private ioctls.
 	 */
-
 	if ((nr >= DRM_COMMAND_BASE) && (nr < DRM_COMMAND_END)
 	    && (nr < DRM_COMMAND_BASE + dev->driver->num_ioctls)) {
 		const struct drm_ioctl_desc *ioctl =
@@ -1181,14 +1187,11 @@ static long vmw_generic_ioctl(struct file *filp, unsigned int cmd,
 			    !capable(CAP_SYS_ADMIN))
 				return -EACCES;
 		}
-
 		if (unlikely(ioctl->cmd != cmd))
 			goto out_io_encoding;
-
 		flags = ioctl->flags;
 	} else if (!drm_ioctl_flags(nr, &flags))
 		return -EINVAL;
-
 	vmaster = vmw_master_check(dev, file_priv, flags);
 	if (IS_ERR(vmaster)) {
 		ret = PTR_ERR(vmaster);
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
index 6a712a8..c196c462 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
@@ -995,6 +995,9 @@ static int vmw_kms_new_framebuffer_surface(struct vmw_private *dev_priv,
 	case DRM_FORMAT_XRGB1555:
 		format = SVGA3D_A1R5G5B5;
 		break;
+    case DRM_FORMAT_ABGR8888:
+        format = SVGA3D_R8G8B8A8_UNORM;
+        break;
 	default:
 		DRM_ERROR("Invalid pixel format: %s\n",
 			  drm_get_format_name(mode_cmd->pixel_format, &format_name));
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index f30e839..f756dc2 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -30,7 +30,10 @@
 #include <drm/drm_plane_helper.h>
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
-
+//fydeos begin
+#include <drm/drm_edid.h>
+#include <drm/drm_connector.h>
+//fydeos end
 
 #define vmw_crtc_to_stdu(x) \
 	container_of(x, struct vmw_screen_target_display_unit, base.crtc)
@@ -117,7 +120,10 @@ struct vmw_screen_target_display_unit {
 	unsigned int cpp;
 };
 
-
+int vmw_get_edid_block(void *data, u8 *edid,
+              unsigned int block, size_t length) {
+    return 0;
+}
 
 static void vmw_stdu_destroy(struct vmw_screen_target_display_unit *stdu);
 
@@ -1424,7 +1430,7 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 	struct drm_plane *primary, *cursor;
 	struct drm_crtc *crtc;
 	int    ret;
-
+    struct edid *edid;
 
 	stdu = kzalloc(sizeof(*stdu), GFP_KERNEL);
 	if (!stdu)
@@ -1502,6 +1508,22 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 	encoder->possible_crtcs = (1 << unit);
 	encoder->possible_clones = 0;
 
+//fydeos begin
+    if (connector->status == connector_status_connected) {
+        connector->override_edid = false;
+        edid = drm_do_get_edid(connector, vmw_get_edid_block, NULL);
+        if (IS_ERR_OR_NULL(edid)) {
+            DRM_INFO("no edid firmware found.\n");
+        } else {
+            ret = drm_connector_update_edid_property(connector, edid);
+            if(ret)
+                DRM_ERROR("error to regist edid:%d", ret);
+            if(connector->edid_blob_ptr)
+                DRM_INFO("edid firmware is loaded.\n");
+        }
+    }
+//fydeos end
+
 	ret = drm_connector_register(connector);
 	if (ret) {
 		DRM_ERROR("Failed to register connector\n");
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c b/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c
index 80a01cd..e4f552c 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c
@@ -830,7 +830,7 @@ int vmw_surface_define_ioctl(struct drm_device *dev, void *data,
 	    srf->num_sizes == 1 &&
 	    srf->sizes[0].width == 64 &&
 	    srf->sizes[0].height == 64 &&
-	    srf->format == SVGA3D_A8R8G8B8) {
+	    (srf->format == SVGA3D_A8R8G8B8 || srf->format == SVGA3D_R8G8B8A8_UNORM)) {
 
 		srf->snooper.image = kzalloc(64 * 64 * 4, GFP_KERNEL);
 		if (!srf->snooper.image) {
@@ -1688,6 +1688,7 @@ vmw_gb_surface_define_internal(struct drm_device *dev,
 	}
 
 	rep->handle      = user_srf->prime.base.hash.key;
+    //DRM_INFO("create handler:0x%x\n", rep->handle); //fydeos log
 	rep->backup_size = res->backup_size;
 	if (res->backup) {
 		rep->buffer_map_handle =
